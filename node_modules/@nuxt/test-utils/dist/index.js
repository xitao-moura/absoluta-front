'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const fs = require('fs');
const path = require('path');
const defu = require('defu');
const getPort = require('get-port');
const got = require('got');
const consola = require('consola');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const defu__default = /*#__PURE__*/_interopDefaultLegacy(defu);
const getPort__default = /*#__PURE__*/_interopDefaultLegacy(getPort);
const got__default = /*#__PURE__*/_interopDefaultLegacy(got);
const consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);

let currentContext;
function createContext(options) {
  const _options = defu__default['default'](options, {
    testDir: path.resolve(process.cwd(), "test"),
    fixture: "fixture",
    configFile: "nuxt.config",
    setupTimeout: 6e4,
    server: options.browser,
    build: options.browser || options.server,
    config: {},
    browserOptions: {
      type: "chromium"
    }
  });
  return setContext({options: _options});
}
function getContext() {
  if (!currentContext) {
    throw new Error("No context is available. (Forgot calling setup or createContext?)");
  }
  return currentContext;
}
function setContext(context) {
  currentContext = context;
  return currentContext;
}

async function loadNuxt() {
  const ctx = getContext();
  const {Nuxt} = await loadNuxtPackage();
  ctx.nuxt = new Nuxt(ctx.options.config);
}
const isNuxtApp = (dir) => {
  return fs.existsSync(dir) && (fs.existsSync(path.resolve(dir, "pages")) || fs.existsSync(path.resolve(dir, "nuxt.config.js")) || fs.existsSync(path.resolve(dir, "nuxt.config.ts")));
};
const resolveRootDir = () => {
  const {options} = getContext();
  const dirs = [
    options.rootDir,
    path.resolve(options.testDir, options.fixture),
    process.cwd()
  ];
  for (const dir of dirs) {
    if (dir && isNuxtApp(dir)) {
      return dir;
    }
  }
  throw new Error("Invalid nuxt app. (Please explicitly set `options.rootDir` pointing to a valid nuxt app)");
};
async function loadFixture() {
  const {options} = getContext();
  options.rootDir = resolveRootDir();
  const {loadNuxtConfig} = await loadNuxtPackage();
  options.config = await loadNuxtConfig({
    rootDir: options.rootDir,
    configFile: options.configFile,
    configOverrides: options.config
  });
  if (!options.config.rootDir) {
    options.config.rootDir = options.rootDir;
  }
  if (!options.config.buildDir) {
    const randomId = Math.random().toString(36).substr(2, 8);
    options.config.buildDir = path.resolve(options.rootDir, ".nuxt", randomId);
  }
}
async function loadNuxtPackage(name = "nuxt") {
  return await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(name + "-edge")); }).catch(() => Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(name)); }));
}
function getNuxt() {
  const ctx = getContext();
  return ctx.nuxt;
}

function expectModuleToBeCalledWith(method, ...args) {
  expect(getNuxt().moduleContainer[method]).toBeCalledWith(...args);
}
function expectModuleNotToBeCalledWith(method, ...args) {
  expect(getNuxt().moduleContainer[method]).not.toBeCalledWith(...args);
}
function expectFileToBeGenerated(path$1) {
  expect(fs.existsSync(path.resolve(getNuxt().options.generate.dir, path$1))).toBe(true);
}
function expectFileNotToBeGenerated(path$1) {
  expect(fs.existsSync(path.resolve(getNuxt().options.generate.dir, path$1))).toBe(false);
}

async function listen() {
  const ctx = getContext();
  const {server} = ctx.options.config;
  const port = await getPort__default['default']({
    ...(server == null ? void 0 : server.port) && {port: Number(server == null ? void 0 : server.port)}
  });
  ctx.url = "http://localhost:" + port;
  await ctx.nuxt.listen(port);
}
function get(path, options) {
  return got__default['default'](url(path), options);
}
function url(path) {
  const ctx = getContext();
  if (!ctx.url) {
    throw new Error("server is not enabled");
  }
  return ctx.url + path;
}

async function createBrowser() {
  const ctx = getContext();
  let playwright;
  try {
    playwright = require("playwright");
  } catch (e) {
    throw new Error(`
      The dependency 'playwright' not found.
      Please run 'yarn add --dev playwright' or 'npm install --save-dev playwright'
    `);
  }
  const {type, launch} = ctx.options.browserOptions;
  if (!playwright[type]) {
    throw new Error(`Invalid browser '${type}'`);
  }
  ctx.browser = await playwright[type].launch(launch);
}
async function getBrowser() {
  const ctx = getContext();
  if (!ctx.browser) {
    await createBrowser();
  }
  return ctx.browser;
}
async function createPage(path, options) {
  const browser = await getBrowser();
  const page = await browser.newPage(options);
  if (path) {
    await page.goto(url(path));
  }
  return page;
}

async function build() {
  const ctx = getContext();
  const {Builder} = await loadNuxtPackage();
  ctx.builder = new Builder(ctx.nuxt);
  await ctx.builder.build();
}

async function generate() {
  const {options} = getContext();
  const nuxt = getNuxt();
  const {Builder, Generator} = await loadNuxtPackage();
  const builder = new Builder(nuxt);
  const generator = new Generator(nuxt, builder);
  await generator.generate(options.generate);
}

function mockConsola() {
  const mock = {};
  consola__default['default'].mockTypes((type) => {
    mock[type] = mock[type] || jest.fn();
    return mock[type];
  });
  return mock;
}

function setupTest(options) {
  const ctx = createContext(options);
  beforeEach(() => {
    setContext(ctx);
  });
  afterEach(() => {
    setContext(void 0);
  });
  afterAll(async () => {
    if (ctx.nuxt) {
      await ctx.nuxt.close();
    }
    if (ctx.browser) {
      await ctx.browser.close();
    }
  });
  test("setup nuxt", async () => {
    if (ctx.options.fixture) {
      await loadFixture();
    }
    if (!ctx.nuxt) {
      await loadNuxt();
      spyOnClass(ctx.nuxt.moduleContainer);
      await ctx.nuxt.ready();
    }
    if (ctx.options.build) {
      await build();
    }
    if (ctx.options.server) {
      await listen();
    }
    if (ctx.options.generate) {
      await generate();
    }
    if (ctx.options.waitFor) {
      await new Promise((resolve) => setTimeout(resolve, ctx.options.waitFor));
    }
    if (ctx.options.browser) {
      await createBrowser();
    }
  }, ctx.options.setupTimeout);
}
function spyOnClass(instance) {
  const proto = Object.getPrototypeOf(instance);
  for (const key of Object.getOwnPropertyNames(proto)) {
    jest.spyOn(instance, key);
  }
}

exports.build = build;
exports.createBrowser = createBrowser;
exports.createContext = createContext;
exports.createPage = createPage;
exports.expectFileNotToBeGenerated = expectFileNotToBeGenerated;
exports.expectFileToBeGenerated = expectFileToBeGenerated;
exports.expectModuleNotToBeCalledWith = expectModuleNotToBeCalledWith;
exports.expectModuleToBeCalledWith = expectModuleToBeCalledWith;
exports.generate = generate;
exports.get = get;
exports.getBrowser = getBrowser;
exports.getContext = getContext;
exports.getNuxt = getNuxt;
exports.listen = listen;
exports.loadFixture = loadFixture;
exports.loadNuxt = loadNuxt;
exports.loadNuxtPackage = loadNuxtPackage;
exports.mockConsola = mockConsola;
exports.setContext = setContext;
exports.setupTest = setupTest;
exports.spyOnClass = spyOnClass;
exports.url = url;
